# 해시 테이블로 매우 빠른 룩업

### 해시 테이블의 무엇인가? 
* 첫번째 항목을 키(Key)와  두번째 항목을 값(Value)로 데이터를 저장하는 자료구조
* 데이터를 O(1)만에 찾을 수 있는 특수한 자료 구조

### 해시 테이블의 장점은 무엇인가?
* 데이터를 O(1)만에 룩업(Look-up)을 할 수 있습니다.
* 빠른 읽기가 가능하다.

### 해시 테이블을 활용한 동의어 사전의 단어를 어떻게 등록이 되는지 설명 해보세요. (곱셉 해시 함수)
1. 해시 테이블에 "bad" = "evil"이라고 등록합니다.
2. bad = 2 x 1x 4 = 8의 값 입니다.
3. 배열 인덱스 8에 evil이 등록이 됩니다.
4. 키(key) = "cab" 와 값(value) = "taxi"을 등록합니다.
5. cab = 3 x 1 x 2 = 6 임으로 배열 인덱스 6에 저장합니다.
6. key 와 value 계속해서 등록합니다.

### 해쉬 테이블은 O(1)만에 찾을 수 있다고 한다. 이유는?
* 키의 값이 위치를 결정하기 때문에 셀을 순회 하면 검색 할 필요없이 바로 룩업을 할 수 있다.
* 자료구조에 읽기는 한 단계로 배열에서 읽을 수 있다.

### 단반향 룩업은 여기서 무엇을 뜻하는가?
* 키가 값의 위치를 결정한다는 해시 테이블의 전제 때문에 한 방향으로만 동작한다.
* 반대로 값은 키의 위치를 알 수 없어서 전부 훓는 것 밖에 할 수 없다.

### 해시 테이블에서 왜 충돌이 발생하는가?
* bad = "evil" 이라고 등록 했지만 dab = "apple"로 등륵한다고 하면 bad = dab 의 배열의 값은 같습니다.

### 해시 테이블에서 충돌을 어떻게 해결하는가?
* 충돌 해결의 고전적인 해결 법은 `분리 연결법`을 사용합니다.
* 충돌이 발생 할 시 하나의 값을 넣은 대신 `참조`를 넣은 방법으로 합니다.
* dab 키를 해싱합니다. 
* dab = 8 임으로 룩업을 해서 배열 인덱스 8에 찾아 갑니다. 
* 8안에 참조 값의 하위 배열안 dab를 0인덱스부터 찾아 갑니다.
* 만약 데이터가 해시 테이블의 한 셀에 들어가 있다면 O(N) 즉 선형 검색을 하는 것과 비슷합니다.
* 분리 연결법은 해시 테이블의 장점을 상쇄 하기 때문에 O(N)이 아닌 O(1)을 수행하도록 재디자인 합니다.

### 충돌이 발생하지 않게 해시 테이블을 효율적으로 어떻게 만드는가?
* 항상 1 ~ 9 사이에 값만 반환하는 해시 함수를 사용합니다.
	* PUT = 16 + 21 + 20 = 57
	* 57은 숫자가 둘 이상임으로 5 + 7 로 쪼갠다.
	* 5 + 7 은 12이니까 1 + 2로 다시 쪼갠다.
	* 1 + 2는 3임으로 PUT은 3으로 해싱이 된다.
* 좋은 해시 함수란 사용 가능한 모든 셀에 데이터를 분산시키는 함수다. 데이터를 넓게 퍼트릴수록 충돌이 적어집니다.

### 충돌 조정은 어떻게 하면 좋을까요?
* 이론상으로는 해시 테이블에 셀을 많이 두는 것이 충돌을 피하는 것이다.
* 하지만 셀이 많아지면 메모리 낭비가 심하다.
* 컴퓨터 과학자의 규칙의 의하면 해시 테이블에 저장된 데이터가 7개면 셀은 10개여야 한다.
* 데이터와 셀 간의 비율 `부하율`이다.
* 이상적인 부하율은 0.7(원소 7개 / 셀 10개)를 의미한다.

### 해시 테이블에서 속도를 어떻게 올리는가?
* array = [61, 30, 91, 11, 54, 38, 72]
* array 배열은 hashTable로 변환 하면 됩니다.

```javascript
hash_table = {61 => true, 30 => true, 91 => true, 
11 => true, 38 => true, 72 => true}
```

